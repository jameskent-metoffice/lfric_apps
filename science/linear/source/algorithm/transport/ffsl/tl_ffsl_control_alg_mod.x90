!-----------------------------------------------------------------------------
! (C) Crown copyright 2026 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routines for managing TL FFSL transport schemes.

module tl_ffsl_control_alg_mod

  ! Infrastructure
  use constants_mod,                     only: r_def, i_def, l_def
  use extrusion_mod,                     only: SHIFTED
  use field_mod,                         only: field_type
  use function_space_collection_mod,     only: function_space_collection
  use function_space_mod,                only: function_space_type
  use fs_continuity_mod,                 only: W3, Wtheta
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_ERROR,   &
                                               LOG_LEVEL_INFO
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use operator_mod,                      only: operator_type
  use timer_mod,                         only: timer

  ! Algorithms
  use ffsl_control_alg_mod,              only: ffsl_control
  use end_of_transport_step_alg_mod,     only: end_of_advective_step_alg, &
                                               end_of_conservative_step_alg
  use tl_end_of_transport_step_alg_mod,  only: tl_end_of_conservative_step_alg
  use tl_end_of_transport_step_alg_mod,  only: tl_end_of_advective_step_alg
  use sci_inject_sh_w3_to_wt_kernel_mod, only: inject_sh_w3_to_wt_kernel_type
  use sci_inject_wt_to_sh_w3_kernel_mod, only: inject_wt_to_sh_w3_kernel_type
  use ffsl_hori_alg_mod,                 only: ffsl_hori_splitting_alg
  use ffsl_vert_alg_mod,                 only: ffsl_vert_transport_alg

  ! Transport Controller
  use split_transport_utils_mod,         only: get_num_split_steps,     &
                                               get_splitting_direction, &
                                               get_splitting_fraction
  use flux_precomputations_alg_mod,      only: flux_precomputations_type
  use transport_controller_mod,          only: transport_controller_type
  use tl_transport_controller_mod,       only: tl_transport_controller_type
  use transport_counter_mod,             only: transport_counter_type
  use transport_metadata_mod,            only: transport_metadata_type
  use wind_precomputations_alg_mod,      only: wind_precomputations_type
  use transport_enumerated_types_mod,    only: direction_v,               &
                                               direction_h,               &
                                               equation_form_advective,   &
                                               equation_form_conservative

  ! Configuration
  use io_config_mod,                     only: subroutine_timers
  use linear_config_mod,                 only: transport_efficiency

  implicit none

  public  :: tl_ffsl_control_alg

  contains

  !> @brief Tangent linear transport with the FFSL scheme.
  !> @details Calls a step of the Flux-Form semi-Lagrangian (FFSL) transport,
  !!          for any form of the transport equation, for the tangent linear
  !!          model.
  !> @param[in,out] field_np1    ACTIVE  Field at the end of the time step
  !> @param[in]     field        ACTIVE  Field at the start of the transport step
  !> @param[in]     ls_field     PASSIVE Field at the start of the transport step
  !> @param[in,out] tl_transport_controller
  !!                             Object controlling transport
  subroutine tl_ffsl_control_alg( field_np1, field, ls_field, &
                                  tl_transport_controller)

    implicit none

    ! Arguments
    type(field_type), target,           intent(inout) :: field_np1
    type(field_type), target,           intent(in)    :: field
    type(field_type), target,           intent(in)    :: ls_field
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller

    ! Internal variables
    integer(kind=i_def)                      :: mesh_id
    type(mesh_type),                 pointer :: mesh
    type(field_type)                         :: pert_u_ls_field_update
    type(field_type),                target  :: ls_field_new_with_pert
    type(field_type),                target  :: field_with_ls_wind

    ! Shifted Mesh and Function Spaces and logicals
    type(function_space_type),       pointer :: w3_shifted_fs
    type(mesh_type),                 pointer :: shifted_mesh
    real(kind=r_def)                         :: dt_frac
    real(kind=r_def)                         :: step_dt
    integer(kind=i_def)                      :: direction
    logical(kind=l_def)                      :: compute_adv_field
    logical(kind=l_def)                      :: enforce_min_value
    integer(kind=i_def)                      :: function_space
    integer(kind=i_def)                      :: vertical_order

    ! Pointers to fields
    type(field_type),         pointer :: field_ptr
    type(field_type),         pointer :: field_np1_ptr
    type(field_type),         pointer :: ls_field_ptr
    type(field_type),         pointer :: ls_field_new_with_pert_ptr
    type(field_type),         target  :: field_w3_shifted
    type(field_type),         target  :: field_np1_w3_shifted
    type(field_type),         target  :: ls_field_w3_shifted
    type(field_type),         target  :: ls_field_new_with_pert_w3_shifted

    type(field_type)            :: ls_increment
    type(field_type)            :: mass_flux_pert
    type(field_type)            :: increment_pert
    type(field_type)            :: mass_flux_pert_ls

    ! Transport controller and metadata
    type(transport_metadata_type),   pointer :: transport_metadata
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_controller_type), pointer :: ls_transport_controller
    type(transport_controller_type), pointer :: pert_transport_controller
    type(wind_precomputations_type), pointer :: ls_wind_precomputations
    type(wind_precomputations_type), pointer :: pert_wind_precomputations
    type(flux_precomputations_type), pointer :: ls_wind_flux_precomp
    type(flux_precomputations_type), pointer :: pert_wind_flux_precomp

    if ( subroutine_timers ) call timer('tl_ffsl_control_alg')

    ! ------------------------------------------------------------------------ !
    ! Extract transport objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !

    ! Mesh
    mesh => field%get_mesh()
    mesh_id = field%get_mesh_id()

    ! Transport controller
    ls_transport_controller   => tl_transport_controller%get_ls_wind_pert_rho_controller()
    pert_transport_controller => tl_transport_controller%get_pert_wind_ls_rho_controller()
    ls_wind_flux_precomp      => ls_transport_controller%get_flux_precomputations()
    pert_wind_flux_precomp    => pert_transport_controller%get_flux_precomputations()
    ls_wind_precomputations   => ls_transport_controller%get_wind_precomputations()
    pert_wind_precomputations => pert_transport_controller%get_wind_precomputations()

    ! Metadata
    transport_metadata => pert_transport_controller%get_transport_metadata()
    transport_counter  => pert_transport_controller%get_transport_counter()

    function_space = field%which_function_space()
    enforce_min_value = transport_metadata%get_enforce_min_value()
    direction = get_splitting_direction(                                       &
        transport_metadata%get_splitting(),                                    &
        transport_counter%get_split_step_of_substep_counter()                  &
    )

    ! Get time step
    dt_frac = get_splitting_fraction(                                          &
        transport_metadata%get_splitting(),                                    &
        transport_counter%get_split_step_of_substep_counter()                  &
    )
    step_dt = dt_frac*transport_counter%get_dt_substep()

    ! Determine whether individual routines should return a flux or updated field
    compute_adv_field = (                                                      &
      transport_metadata%get_equation_form() == equation_form_advective        &
      .or. transport_counter%get_split_step_of_substep_counter() /=            &
           get_num_split_steps(transport_metadata%get_splitting())             &
    )

    ! Initialise fields
    call ls_field_new_with_pert%initialise(ls_field%get_function_space())
    call pert_u_ls_field_update%initialise(ls_field%get_function_space())
    call field_with_ls_wind%initialise(field%get_function_space())

    ! ======================================================================== !
    ! Convert to shifted W3 if required
    ! ======================================================================== !

    if (function_space == Wtheta) then
      ! If the variable is in Wtheta, move into shifted W3
      shifted_mesh => mesh_collection%get_mesh(mesh, SHIFTED)
      w3_shifted_fs => function_space_collection%get_fs(shifted_mesh, 0_i_def, &
                                                        0_i_def, W3)
      call field_w3_shifted%initialise( vector_space = w3_shifted_fs )
      call field_np1_w3_shifted%initialise( vector_space = w3_shifted_fs )
      call ls_field_w3_shifted%initialise( vector_space = w3_shifted_fs )
      call ls_field_new_with_pert_w3_shifted%initialise( vector_space = w3_shifted_fs )
      if (enforce_min_value) then
        call invoke( setval_X(field_w3_shifted, field), &
                     setval_X(ls_field_w3_shifted, ls_field) )
      else
        ! Interpolate in bottom/top layers
        call invoke( inject_wt_to_sh_w3_kernel_type(field_w3_shifted, field), &
                     inject_wt_to_sh_w3_kernel_type(ls_field_w3_shifted, ls_field) )
      end if
      field_ptr        => field_w3_shifted
      field_np1_ptr    => field_np1_w3_shifted
      ls_field_ptr     => ls_field_w3_shifted
      ls_field_new_with_pert_ptr => ls_field_new_with_pert_w3_shifted
    else
      ! Stay on current mesh
      field_ptr        => field
      field_np1_ptr    => field_with_ls_wind
      ls_field_ptr     => ls_field
      ls_field_new_with_pert_ptr => ls_field_new_with_pert
    end if

    ! Consider advective form transport:
    ! We require the terms ls_u.grad(f') + u'.grad(ls_f)
    ! 1 - is this correct for FFSL/SL schemes, or do we need to expand the last
    !     term: u'.grad(ls_f) = u.grad(ls_f) - ls_u.grad(ls_f)
    !     Can we approximate as: u'.grad(ls_f - dt ls u.grad(ls_f)) - ls_u.grad(ls_f)
    !     Or just:               u'.grad(ls_f - dt ls u.grad(ls_f))
    ! 2 - do we need to think about departure distances and how they are computed?
    ! 3 - Advective form FFSL is computed as: (q - dt div(u q))/(1 - dt div(u))
    !     Is this acceptible? Do we need to rewrite this term to avoid the division
    !     (this can be done by doing rewriting the FFSL kernel to use cell centred wind)
    !     or can we use the SL scheme for advective form?

    ! ====================================================================== !
    ! ls wind perturbation state ls_u.grad(f')
    ! ====================================================================== !

    select case (direction)
    case (direction_v)
      vertical_order = transport_metadata%get_ffsl_vertical_order()
      call ffsl_vert_transport_alg(                                            &
              mass_flux_pert, increment_pert, field_np1_ptr, field_ptr,        &
              step_dt, ls_transport_controller, vertical_order,                &
              compute_adv_inc=.false., compute_field_np1=compute_adv_field     &
      )

    case (direction_h)
      call ffsl_hori_splitting_alg(                                            &
              mass_flux_pert, field_np1_ptr, field_ptr, step_dt,               &
              ls_transport_controller,                                         &
              compute_field_np1=compute_adv_field                              &
      )

    case default
      call log_event( "TL FFSL control: Unrecognized pert field direction", LOG_LEVEL_ERROR )

    end select

    ! Convert field_np1 back to Wtheta, if required
    if (function_space == Wtheta .and. compute_adv_field) then
      ! If Wtheta variable, move field_np1 back to Wtheta
      if (enforce_min_value) then
        ! Can't generate negatives by extrapolation, so just inject
        call invoke( setval_X(field_with_ls_wind, field_np1_w3_shifted) )
      else
        ! Extrapolation allowed
        call invoke( inject_sh_w3_to_wt_kernel_type(field_with_ls_wind,        &
                                                    field_np1_w3_shifted) )
      end if
    end if

    ! ====================================================================== !
    ! perturbation wind ls state u'.grad(ls_f)
    ! ====================================================================== !

    ! Use constant reconstruction to ensure linearity in u'
    call pert_transport_controller%set_linear_scheme(.true.)

    select case (direction)
    case (direction_v)
      vertical_order = 0
      call ffsl_vert_transport_alg(                                            &
              mass_flux_pert_ls, ls_increment,                                 &
              ls_field_new_with_pert_ptr, ls_field_ptr,                        &
              step_dt, pert_transport_controller, vertical_order,              &
              compute_adv_inc=.false., compute_field_np1=compute_adv_field     &
      )

    case (direction_h)
      call ffsl_hori_splitting_alg(                                            &
              mass_flux_pert_ls, ls_field_new_with_pert_ptr,                   &
              ls_field_ptr, step_dt,                                           &
              pert_transport_controller,                                       &
              compute_field_np1=compute_adv_field                              &
      )

    case default
      call log_event( "TL FFSL control: Unrecognized ls field direction", LOG_LEVEL_ERROR )

    end select

    ! Reset reconstruction order
    call pert_transport_controller%set_linear_scheme(.false.)

    ! Convert field_np1 back to Wtheta, if required
    if (function_space == Wtheta .and. compute_adv_field) then
      ! If Wtheta variable, move field_np1 back to Wtheta
      if (enforce_min_value) then
        ! Can't generate negatives by extrapolation, so just inject
        call invoke( setval_X(ls_field_new_with_pert, ls_field_new_with_pert_w3_shifted) )
      else
        ! Extrapolation allowed
        call invoke( inject_sh_w3_to_wt_kernel_type(ls_field_new_with_pert,  &
                                                    ls_field_new_with_pert_w3_shifted) )
      end if
    end if

    ! End of transport step generic routines

    select case ( transport_metadata%get_equation_form() )

    case ( equation_form_conservative )

      ! Include dt in the mass flux
      call invoke( inc_a_times_X(step_dt, mass_flux_pert_ls) )

      ! If this is the final step, field_np1 will be computed here from the fluxes
      ! over the whole transport step
      ! If this is not the final step, field_np1 already includes the *advective*
      ! increment, and may be adjusted to enforce min value or in blending zone
      call end_of_conservative_step_alg(                                       &
              ls_field_new_with_pert, ls_field, mass_flux_pert_ls,             &
              pert_wind_flux_precomp,                                          &
              transport_counter, transport_metadata                            &
      )

    case ( equation_form_advective )
      ! End of step: if necessary enforce min val and overwrite in blending zone
      call end_of_advective_step_alg(                                          &
              ls_field_new_with_pert, ls_field, transport_counter,             &
              transport_metadata                                               &
      )

    case default
      call log_event( "FFSL control: Unrecognised LS pert equation", LOG_LEVEL_ERROR )

    end select

    ! End of transport step generic routines

    ! Compute pert wnid ls field update and combine for perturbation field np1
    if ( compute_adv_field ) then
      call invoke( X_minus_Y(pert_u_ls_field_update,                           &
                             ls_field_new_with_pert, ls_field),                &
                   X_plus_Y(field_np1, field_with_ls_wind,                     &
                            pert_u_ls_field_update) )
    end if

    select case ( transport_metadata%get_equation_form() )

    case ( equation_form_conservative )

      ! Include dt in the mass flux
      call invoke( inc_a_times_X(step_dt, mass_flux_pert) )

      ! If this is the final step, field_np1 will be computed here from the fluxes
      ! over the whole transport step
      ! If this is not the final step, field_np1 already includes the *advective*
      ! increment, and may be adjusted to enforce min value or in blending zone

      call tl_end_of_conservative_step_alg(                                    &
          field_np1, field, mass_flux_pert, mass_flux_pert_ls,                 &
          ls_wind_flux_precomp, pert_wind_flux_precomp,                        &
          transport_counter, transport_metadata                                &
      )

    case ( equation_form_advective )
      ! End of step: if necessary enforce min val and overwrite in blending zone
      call tl_end_of_advective_step_alg(                                       &
              field_np1, field, transport_counter, transport_metadata          &
      )

    case default
      call log_event( "FFSL control: Unrecognised pert equation", LOG_LEVEL_ERROR )

    end select

    if ( subroutine_timers ) call timer('tl_ffsl_control_alg')

  end subroutine tl_ffsl_control_alg

end module tl_ffsl_control_alg_mod