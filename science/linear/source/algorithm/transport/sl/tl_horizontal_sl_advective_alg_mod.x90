!-----------------------------------------------------------------------------
! (C) Crown copyright 2026 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routine for TL SL horizontal transport.

module tl_horizontal_sl_advective_alg_mod

  ! Constants and types
  use constants_mod,                     only: r_tran, i_def, l_def
  use field_mod,                         only: field_type
  use integer_field_mod,                 only: integer_field_type
  use mesh_mod,                          only: mesh_type
  use timer_mod,                         only: timer

  ! Transport control
  use flux_precomputations_alg_mod,      only: flux_precomputations_type
  use split_transport_utils_mod,         only: get_splitting_fraction,          &
                                               get_dry_config
  use transport_controller_mod,          only: transport_controller_type
  use tl_transport_controller_mod,       only: tl_transport_controller_type
  use transport_counter_mod,             only: transport_counter_type
  use transport_enumerated_types_mod,    only: monotone_none, direction_h
  use transport_metadata_mod,            only: transport_metadata_type
  use wind_precomputations_alg_mod,      only: wind_precomputations_type

  ! Algorithms and Kernels
  use end_of_transport_step_alg_mod,     only: end_of_advective_step_alg
  use horizontal_cubic_sl_kernel_mod,    only: horizontal_cubic_sl_kernel_type
  use horizontal_cubic_sl_sphere_kernel_mod,                                   &
                                         only: horizontal_cubic_sl_sphere_kernel_type
  use horizontal_linear_sl_kernel_mod,   only: horizontal_linear_sl_kernel_type
  use limited_area_lbc_alg_mod,          only: overwrite_blending_zone_rtran
  use remap_on_extended_mesh_alg_mod,    only: remap_on_extended_mesh

  ! Pointers to other objects
  use sci_geometric_constants_mod,       only: get_panel_id
  use transport_constants_mod,           only: get_panel_edge_dist

  ! Configs
  use base_mesh_config_mod,              only: topology, geometry,              &
                                               topology_fully_periodic,         &
                                               topology_non_periodic,           &
                                               geometry_spherical
  use boundaries_config_mod,             only: limited_area,                    &
                                               transport_boundary_depth,        &
                                               transport_overwrite_freq,        &
                                               transport_overwrite_freq_all
  use departure_points_config_mod,       only: share_stencil_extent
  use io_config_mod,                     only: subroutine_timers
  use transport_config_mod,              only:                                  &
                                           panel_edge_treatment,                &
                                           panel_edge_treatment_extended_mesh,  &
                                           ffsl_unity_3d

  implicit none

  private

  public :: tl_horizontal_sl_advective_alg
  public :: tl_horizontal_sl_inner_alg
  public :: tl_horizontal_sl_outer_alg

contains

  !-----------------------------------------------------------------------------
  !> @brief Tangent linear transport with the horizontal semi-Lagrangian (SL) scheme
  !!
  !> @param[in,out] field_np1    ACTIVE  Field at the end of the time step
  !> @param[in]     field_n      ACTIVE  Field at the start of the transport step
  !> @param[in]     ls_field     PASSIVE Field at the start of the transport step
  !> @param[in,out] tl_transport_controller
  !!                             Object controlling transport
  subroutine tl_horizontal_sl_advective_alg( field_np1, field_n, ls_field,     &
                                             tl_transport_controller )

    implicit none

    ! Arguments
    type(field_type),                   intent(inout) :: field_np1
    type(field_type),                   intent(in)    :: field_n
    type(field_type),                   intent(in)    :: ls_field
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller

    type(transport_controller_type), pointer :: ls_transport_controller
    type(transport_controller_type), pointer :: pert_transport_controller

    type(field_type) :: ls_field_np1
    type(field_type) :: ls_field_inc
    type(field_type) :: field_x
    type(field_type) :: field_y
    type(field_type) :: ls_field_x
    type(field_type) :: ls_field_y

    if ( subroutine_timers ) call timer('tl_horizontal_sl_advective_alg')

    ! ------------------------------------------------------------------------ !
    ! Extract transport objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !

    ! Transport controller
    ls_transport_controller   => tl_transport_controller%get_ls_wind_pert_rho_controller()
    pert_transport_controller => tl_transport_controller%get_pert_wind_ls_rho_controller()

    ! Initialise
    call ls_field_np1%initialise(ls_field%get_function_space())
    call ls_field_inc%initialise(ls_field%get_function_space())
    call field_x%initialise( field_n%get_function_space() )
    call field_y%initialise( field_n%get_function_space() )
    call ls_field_x%initialise( ls_field%get_function_space() )
    call ls_field_y%initialise( ls_field%get_function_space() )

    ! Consider advective form transport:
    ! We require the terms ls_u.grad(f') + u'.grad(ls_f)

    ! ====================================================================== !
    ! ls wind perturbation state ls_u.grad(f')
    ! ====================================================================== !

    call tl_horizontal_sl_inner_alg( field_x, field_y, field_n,                &
                                     ls_transport_controller )
    call tl_horizontal_sl_outer_alg( field_np1, field_n, field_x, field_y,     &
                                     ls_transport_controller )

    ! ====================================================================== !
    ! perturbation wind ls state u'.grad(ls_f)
    ! ====================================================================== !

    call tl_horizontal_sl_inner_alg( ls_field_x, ls_field_y, ls_field,         &
                                     pert_transport_controller )
    call tl_horizontal_sl_outer_alg( ls_field_np1, ls_field,                   &
                                     ls_field_x, ls_field_y, pert_transport_controller )

    ! Combine them to update the perturbation field
    call invoke( X_minus_Y(ls_field_inc, ls_field_np1, ls_field),              &
                 inc_X_plus_Y( field_np1, ls_field_inc)  )

    if ( subroutine_timers ) call timer('tl_horizontal_sl_advective_alg')

  end subroutine tl_horizontal_sl_advective_alg


  !-----------------------------------------------------------------------------
  !> @brief The inner COSMIC splitting step for SL tangent linear advection.
  !> @details This algorithm performs the inner step of the COSMIC splitting
  !!          for horizontal semi-Lagrangian tangent linear advective transport.
  !!          It uses linear interpolation and a half time step.
  !> @param[in,out]  field_x                Field after advection in x
  !> @param[in,out]  field_y                Field after advection in y
  !> @param[in]      field_n                Field at timestep n
  !> @param[in,out]  transport_controller   Object containing metadata and
  !!                                        precomputations for controlling the
  !!                                        transport of the field
  subroutine tl_horizontal_sl_inner_alg( field_x, field_y, field_n,            &
                                         transport_controller )

    implicit none

    ! Arguments
    type(field_type),                intent(inout) :: field_x
    type(field_type),                intent(inout) :: field_y
    type(field_type),                intent(in)    :: field_n
    type(transport_controller_type), intent(inout) :: transport_controller

    ! Internal Variables
    type(field_type), target :: field_big_halo
    type(field_type)         :: field_xp
    type(field_type)         :: field_yp
    type(field_type)         :: half_increment_x
    type(field_type)         :: half_increment_y

    ! Fields for remapping
    type(mesh_type),          pointer :: mesh
    type(field_type),         pointer :: panel_id
    type(integer_field_type), pointer :: panel_edge_dist(:)

    ! Scalars
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: splitting
    integer(kind=i_def) :: step
    integer(kind=i_def) :: stencil_extent
    integer(kind=i_def) :: hori_monotone
    logical(kind=l_def) :: monotone_remap
    logical(kind=l_def) :: is_cubed_sphere
    logical(kind=l_def) :: do_overwrite
    real(kind=r_tran)   :: dt_frac, dt
    real(kind=r_tran)   :: one_over_dt, half_dt

    ! Transport objects
    type(wind_precomputations_type), pointer :: wind_precomputations
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_metadata_type),   pointer :: transport_metadata
    type(field_type),                pointer :: dep_dist_xy
    integer(kind=i_def)                      :: dep_stencil_extent_xy

    if ( subroutine_timers ) call timer('tl_horizontal_sl_inner_alg')

    ! Get mesh ID and panel ID
    mesh_id = field_n%get_mesh_id()

    is_cubed_sphere = (                                                        &
      geometry == geometry_spherical .and. topology == topology_fully_periodic &
    )

    if (is_cubed_sphere) then
      panel_id => get_panel_id(mesh_id)
      panel_edge_dist => get_panel_edge_dist(mesh_id)
    end if

    ! Get transport controlling objects
    mesh => field_n%get_mesh()
    transport_counter => transport_controller%get_transport_counter()
    transport_metadata => transport_controller%get_transport_metadata()

    ! Get time step
    dt_frac = get_splitting_fraction(                                          &
        transport_metadata%get_splitting(),                                    &
        transport_counter%get_split_step_of_substep_counter()                  &
    )
    dt = dt_frac*transport_counter%get_dt_substep()

    ! Get departure points
    splitting = transport_metadata%get_splitting()
    step = transport_counter%get_split_step_of_substep_counter()

    wind_precomputations => transport_controller%get_wind_precomputations()
    dep_dist_xy => wind_precomputations%get_dep_dist_xy(                     &
        mesh_id, splitting, step, .false.                                    &
    )
    dep_stencil_extent_xy = wind_precomputations%get_dep_stencil_extent_xy(  &
        mesh_id, splitting, step, .false.                                    &
    )

    ! Get monotone option
    hori_monotone = transport_metadata%get_horizontal_monotone()

    ! Get stencil size: this corresponds to the value from the departure distances
    stencil_extent = dep_stencil_extent_xy

    ! Initialise fields
    call field_xp%initialise( vector_space = field_n%get_function_space() )
    call field_yp%initialise( vector_space = field_n%get_function_space() )
    call half_increment_x%initialise( vector_space = field_n%get_function_space() )
    call half_increment_y%initialise( vector_space = field_n%get_function_space() )

    ! If needed remap the field on an extended cubed sphere
    if ( panel_edge_treatment == panel_edge_treatment_extended_mesh ) then
      monotone_remap = ( hori_monotone /= monotone_none )
      call remap_on_extended_mesh(field_big_halo, field_n, monotone_remap,     &
                                  transport_metadata%get_enforce_min_value(),  &
                                  transport_metadata%get_min_value(),          &
                                  stencil_extent )
    else
      call field_big_halo%initialise( field_n%get_function_space(),            &
                                      halo_depth = stencil_extent )
      call invoke( setval_x( field_big_halo, field_n ) )
    end if

    ! First advective step with linear interpolation
    call invoke( horizontal_linear_sl_kernel_type( field_xp,                   &
                                                   field_yp,                   &
                                                   field_big_halo,             &
                                                   stencil_extent,             &
                                                   dep_dist_xy ) )

    ! Constants to get increments
    one_over_dt = 1.0_r_tran / dt
    half_dt = 0.5_r_tran * dt

    call invoke( X_minus_Y(half_increment_x, field_n, field_xp),               &
                 inc_a_times_X(one_over_dt, half_increment_x),                 &
                 X_minus_bY(field_x, field_n, half_dt, half_increment_x),      &
                 X_minus_Y(half_increment_y, field_n, field_yp),               &
                 inc_a_times_X(one_over_dt, half_increment_y),                 &
                 X_minus_bY(field_y, field_n, half_dt, half_increment_y) )

    do_overwrite = (                                                           &
      limited_area .and. topology == topology_non_periodic .and.               &
      transport_overwrite_freq == transport_overwrite_freq_all                 &
    )
    if (do_overwrite) then
      call overwrite_blending_zone_rtran(                                      &
              field_x, field_n, depth=transport_boundary_depth                 &
      )
      call overwrite_blending_zone_rtran(                                      &
              field_y, field_n, depth=transport_boundary_depth                 &
      )
    end if

    if ( subroutine_timers ) call timer('tl_horizontal_sl_inner_alg')

  end subroutine tl_horizontal_sl_inner_alg


  !-----------------------------------------------------------------------------
  !> @brief Solves the horizontal advection equation using a semi-Lagrangian scheme.
  !> @details The algorithm solves the horizontal advection equation by performing
  !!          multiple 1D horizontal semi-Lagrangian advective transports and COSMIC
  !!          splitting.
  !!
  !> @param[in,out]  field_np1              Field at timestep n+1
  !> @param[in]      field_n                Field at timestep n
  !> @param[in]      field_x                Field advected in x
  !> @param[in]      field_y                Field advected in y
  !> @param[in,out]  transport_controller   Object containing metadata and
  !!                                        precomputations for controlling the
  !!                                        transport of the field
  subroutine tl_horizontal_sl_outer_alg( field_np1, field_n, field_x, field_y, &
                                          transport_controller )

    implicit none

    ! Arguments
    type(field_type),                intent(inout) :: field_np1
    type(field_type),                intent(in)    :: field_n
    type(field_type),                intent(in)    :: field_x
    type(field_type),                intent(in)    :: field_y
    type(transport_controller_type), intent(inout) :: transport_controller

    ! Internal Variables
    type(field_type), target :: field_x_big_halo
    type(field_type), target :: field_y_big_halo
    type(field_type)         :: increment_x
    type(field_type)         :: increment_y
    type(field_type)         :: increment

    ! Fields for remapping
    type(mesh_type),          pointer :: mesh
    type(field_type),         pointer :: panel_id
    type(integer_field_type), pointer :: panel_edge_dist(:)

    ! Scalars
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: splitting
    integer(kind=i_def) :: step
    integer(kind=i_def) :: stencil_extent
    integer(kind=i_def) :: hori_monotone
    logical(kind=l_def) :: monotone_remap
    logical(kind=l_def) :: is_cubed_sphere
    real(kind=r_tran)   :: dt_frac, dt

    ! Transport objects
    type(wind_precomputations_type), pointer :: wind_precomputations
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_metadata_type),   pointer :: transport_metadata
    type(field_type),                pointer :: dep_dist_xy
    integer(kind=i_def)                      :: dep_stencil_extent_xy

    if ( subroutine_timers ) call timer('tl_horizontal_sl_outer_alg')

    ! Get mesh ID and panel ID
    mesh_id = field_n%get_mesh_id()

    is_cubed_sphere = (                                                        &
      geometry == geometry_spherical .and. topology == topology_fully_periodic &
    )

    if (is_cubed_sphere) then
      panel_id => get_panel_id(mesh_id)
      panel_edge_dist => get_panel_edge_dist(mesh_id)
    end if

    ! Get transport controlling objects
    mesh => field_n%get_mesh()
    transport_counter => transport_controller%get_transport_counter()
    transport_metadata => transport_controller%get_transport_metadata()

    ! Get time step
    dt_frac = get_splitting_fraction(                                          &
        transport_metadata%get_splitting(),                                    &
        transport_counter%get_split_step_of_substep_counter()                  &
    )
    dt = dt_frac*transport_counter%get_dt_substep()

    ! Get departure points
    splitting = transport_metadata%get_splitting()
    step = transport_counter%get_split_step_of_substep_counter()

    wind_precomputations => transport_controller%get_wind_precomputations()
    dep_dist_xy => wind_precomputations%get_dep_dist_xy(                       &
        mesh_id, splitting, step, .false.                                      &
    )
    dep_stencil_extent_xy = wind_precomputations%get_dep_stencil_extent_xy(    &
        mesh_id, splitting, step, .false.                                      &
    )

    ! Get monotone option
    hori_monotone = transport_metadata%get_horizontal_monotone()

    ! Initialise fields
    call increment%initialise( vector_space = field_n%get_function_space() )
    call increment_x%initialise( vector_space = field_n%get_function_space() )
    call increment_y%initialise( vector_space = field_n%get_function_space() )

    ! Outer advective step with cubic interpolation
    stencil_extent = MIN(dep_stencil_extent_xy + 1, mesh%get_halo_depth())

    ! If needed remap the field on an extended cubed sphere
    if ( panel_edge_treatment == panel_edge_treatment_extended_mesh ) then
      monotone_remap = ( hori_monotone /= monotone_none )
      call remap_on_extended_mesh(field_x_big_halo, field_x, monotone_remap,   &
                                  transport_metadata%get_enforce_min_value(),  &
                                  transport_metadata%get_min_value(),          &
                                  stencil_extent )
      call remap_on_extended_mesh(field_y_big_halo, field_y, monotone_remap,   &
                                  transport_metadata%get_enforce_min_value(),  &
                                  transport_metadata%get_min_value(),          &
                                  stencil_extent )
    else
      call field_x_big_halo%initialise( field_x%get_function_space(), &
                                        halo_depth = stencil_extent )
      call field_y_big_halo%initialise( field_y%get_function_space(), &
                                        halo_depth = stencil_extent )
      call invoke( setval_x( field_x_big_halo, field_x ), &
                   setval_x( field_y_big_halo, field_y ) )
    end if

    if (is_cubed_sphere) then
      call invoke( name='tl_horizontal_cubic_sl_sphere',                       &
                   horizontal_cubic_sl_sphere_kernel_type(                     &
                                                increment_x,                   &
                                                increment_y,                   &
                                                field_x_big_halo,              &
                                                stencil_extent,                &
                                                field_y_big_halo,              &
                                                stencil_extent,                &
                                                dep_dist_xy,                   &
                                                panel_id,                      &
                                                panel_edge_dist,               &
                                                hori_monotone ) )
    else
      call invoke( horizontal_cubic_sl_kernel_type(                            &
                                                increment_x,                   &
                                                increment_y,                   &
                                                field_x_big_halo,              &
                                                stencil_extent,                &
                                                field_y_big_halo,              &
                                                stencil_extent,                &
                                                dep_dist_xy,                   &
                                                hori_monotone ) )
    end if

    ! Collect the increments
    call invoke( X_plus_Y(increment, increment_x, increment_y),                &
                 X_plus_Y(field_np1, field_n, increment) )

    ! End of step: if necessary enforce min val and overwrite in blending zone
    call end_of_advective_step_alg(                                            &
            field_np1, field_n, transport_counter, transport_metadata          &
    )

    if ( subroutine_timers ) call timer('tl_horizontal_sl_outer_alg')

  end subroutine tl_horizontal_sl_outer_alg

end module tl_horizontal_sl_advective_alg_mod