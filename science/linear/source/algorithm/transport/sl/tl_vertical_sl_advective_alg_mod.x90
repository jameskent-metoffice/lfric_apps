!-----------------------------------------------------------------------------
! (C) Crown copyright 2026 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routines for TL SL vertical transport.

module tl_vertical_sl_advective_alg_mod

  ! Constants and types
  use constants_mod,                     only: r_def, i_def, l_def
  use mesh_mod,                          only: mesh_type
  use field_mod,                         only: field_type
  use integer_field_mod,                 only: integer_field_type
  use timer_mod,                         only: timer

  ! Algorithms and kernels
  use end_of_transport_step_alg_mod,   only: end_of_advective_step_alg
  use vertical_cubic_sl_kernel_mod,    only: vertical_cubic_sl_kernel_type

  ! Transport Controllers
  use transport_controller_mod,          only: transport_controller_type
  use transport_counter_mod,             only: transport_counter_type
  use tl_transport_controller_mod,       only: tl_transport_controller_type
  use transport_metadata_mod,            only: transport_metadata_type
  use wind_precomputations_alg_mod,      only: wind_precomputations_type

  ! Configuration
  use io_config_mod,                     only: subroutine_timers
  use transport_config_mod,              only: vertical_sl_order,                &
                                               vertical_sl_order_cubic,          &
                                               vertical_sl_order_cubic_hermite,  &
                                               vertical_sl_order_linear

  implicit none

  private

  public :: tl_vertical_sl_control_alg
  public :: tl_vertical_sl_advective_alg

contains

  !-----------------------------------------------------------------------------
  !> @brief Control for the tangent linear transport with the vertical
  !!        semi-Lagrangian (SL) scheme
  !> @param[in,out] field_np1    ACTIVE  Field at the end of the time step
  !> @param[in]     field_n      ACTIVE  Field at the start of the transport step
  !> @param[in]     ls_field     PASSIVE Field at the start of the transport step
  !> @param[in,out] tl_transport_controller
  !!                             Object controlling transport
  subroutine tl_vertical_sl_control_alg( field_np1, field_n, ls_field,         &
                                         tl_transport_controller )

    implicit none

    ! Arguments
    type(field_type),                   intent(inout) :: field_np1
    type(field_type),                   intent(in)    :: field_n
    type(field_type),                   intent(in)    :: ls_field
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller

    type(transport_controller_type), pointer :: ls_transport_controller
    type(transport_controller_type), pointer :: pert_transport_controller

    type(field_type) :: ls_field_np1
    type(field_type) :: ls_field_inc

    if ( subroutine_timers ) call timer('tl_vertical_sl_control_alg')

    ! ------------------------------------------------------------------------ !
    ! Extract transport objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !

    ! Transport controller
    ls_transport_controller   => tl_transport_controller%get_ls_wind_pert_rho_controller()
    pert_transport_controller => tl_transport_controller%get_pert_wind_ls_rho_controller()

    ! Initialise
    call ls_field_np1%initialise(ls_field%get_function_space())
    call ls_field_inc%initialise(ls_field%get_function_space())

    ! Consider advective form transport:
    ! We require the terms ls_u.grad(f') + u'.grad(ls_f)

    ! ====================================================================== !
    ! ls wind perturbation state ls_u.grad(f')
    ! ====================================================================== !

    call tl_vertical_sl_advective_alg( field_np1, field_n,                      &
                                       ls_transport_controller,                 &
                                       linear_scheme=.false. )

    ! ====================================================================== !
    ! perturbation wind ls state u'.grad(ls_f)
    ! ====================================================================== !

    ! Do the vertical transport
    call tl_vertical_sl_advective_alg( ls_field_np1, ls_field,                  &
                                       pert_transport_controller,               &
                                       linear_scheme=.true. )

    ! Combine them to update the perturbation field
    call invoke( X_minus_Y(ls_field_inc, ls_field_np1, ls_field),              &
                 inc_X_plus_Y( field_np1, ls_field_inc)  )

    if ( subroutine_timers ) call timer('tl_vertical_sl_control_alg')

  end subroutine tl_vertical_sl_control_alg


  !-----------------------------------------------------------------------------
  !> @brief Advective semi-Lagrangian (SL) transport for the tangent linear model
  !> @param[in,out] field_np1     Field at the end of the time step
  !> @param[in]     field_n       Field at the start of the transport step
  !> @param[in,out] transport_controller
  !!                              Object controlling transport
  !> @param[in]     linear_scheme Option to use linear interpolation
  subroutine tl_vertical_sl_advective_alg( field_np1, field_n,                 &
                                           transport_controller, linear_scheme )

    implicit none

    ! Arguments
    type(field_type),                   intent(inout) :: field_np1
    type(field_type),                   intent(in)    :: field_n
    type(transport_controller_type),    intent(inout) :: transport_controller
    logical(kind=l_def),                intent(in)    :: linear_scheme

    ! Mesh and transport objects
    type(mesh_type),                 pointer :: mesh
    type(wind_precomputations_type), pointer :: wind_precomputations
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_metadata_type),   pointer :: transport_metadata
    integer(kind=i_def)                      :: monotone, monotone_order
    integer(kind=i_def)                      :: sl_order
    integer(kind=i_def)                      :: mesh_id
    integer(kind=i_def)                      :: space
    integer(kind=i_def)                      :: step
    integer(kind=i_def)                      :: splitting
    logical(kind=l_def)                      :: reversibility
    logical(kind=l_def)                      :: log_space

    ! Interpolation coefficients
    type(field_type),         pointer :: linear_coeffs(:)
    type(field_type),         pointer :: interp_coeffs(:)
    type(integer_field_type), pointer :: interp_indices(:)

    if ( subroutine_timers ) call timer('tl_vertical_sl_advective_alg')

    ! Get transport objects
    mesh => field_n%get_mesh()
    wind_precomputations => transport_controller%get_wind_precomputations()
    transport_counter => transport_controller%get_transport_counter()
    transport_metadata => transport_controller%get_transport_metadata()

    mesh_id = mesh%get_id()
    space = field_n%which_function_space()
    monotone = transport_metadata%get_vertical_monotone()
    monotone_order = transport_metadata%get_vertical_monotone_order()
    reversibility = transport_metadata%get_reversible()
    log_space  = transport_metadata%get_log_space()
    step = transport_counter%get_split_step_of_substep_counter()
    splitting = transport_metadata%get_splitting()

    sl_order = vertical_sl_order
    if ( reversibility ) then
      sl_order = vertical_sl_order_cubic_hermite
    end if

    ! Compute SL advective transport (vertical only) of
    ! field_np1 =  field_n_D
    call invoke( setval_X(field_np1, field_n) )

    ! Get the SL interpolation coefficients and indices
    linear_coeffs => wind_precomputations%get_vert_sl_coeff(                   &
        mesh_id, space, vertical_sl_order_linear, splitting, step              &
    )
    interp_coeffs => wind_precomputations%get_vert_sl_coeff(                   &
        mesh_id, space, sl_order, splitting, step                              &
    )
    interp_indices => wind_precomputations%get_vert_sl_index(                  &
        mesh_id, space, sl_order, splitting, step                              &
    )

    if ( linear_scheme ) then
      sl_order = vertical_sl_order_linear
    end if

    ! Cubic (Lagrange or Hermite) semi-Lagrangian transport
    call invoke( vertical_cubic_sl_kernel_type( field_np1,                     &
                                                interp_coeffs(1),              &
                                                interp_coeffs(2),              &
                                                interp_coeffs(3),              &
                                                interp_coeffs(4),              &
                                                interp_indices(1),             &
                                                interp_indices(2),             &
                                                interp_indices(3),             &
                                                interp_indices(4),             &
                                                linear_coeffs(1),              &
                                                linear_coeffs(2),              &
                                                linear_scheme,                 &
                                                monotone,                      &
                                                monotone_order,                &
                                                log_space ) )

    ! End of step: if necessary enforce min val and overwrite in blending zone
    call end_of_advective_step_alg(                                            &
            field_np1, field_n, transport_counter, transport_metadata          &
    )

    if ( subroutine_timers ) call timer( 'tl_vertical_sl_advective_alg' )

  end subroutine tl_vertical_sl_advective_alg

end module tl_vertical_sl_advective_alg_mod